#!/usr/bin/env python3
"""
Setup script for ubuntu-dev
Platform: linux
OS: ubuntu 22.04

Generated by start-vm
Python 3.8+ compatible, uses only standard library
Data-driven architecture with unified operation execution
"""

import argparse
import platform
import re
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Union

# ============================================================================
# RECIPE DATA
# ============================================================================

RECIPE = {
    'name': "ubuntu-dev",
    'platform': "linux",
    'os': "ubuntu",
    'version': "22.04",
    'release': "jammy",
}

PATHS = {
    'config_dir': Path("config") / "" if "" else None,
    'default_dir': Path("default"),
    'home_dir': Path.home(),
    'config_dst': Path.home() / ".config",
    'backup_dir': None,  # Set dynamically with timestamp
}

FILE_SETS = {   'configs': [],
    'defaults': [   '.fonts',
                    'bin',
                    '.vimrc-heavy',
                    '.bashrc',
                    '.SciTEUser.properties',
                    '.xinitrc',
                    '.gtkrc-2.0',
                    '.vimrc',
                    '.ghci',
                    'src']}

SECTIONS = [   {   'install': ['nodejs', 'npm', 'docker.io', 'postgresql-client'],
        'name': 'dev-tools',
        'type': 'debian_packages'},
    {   'install': ['pytest', 'black', 'pylint', 'ipython', 'jupyter'],
        'name': 'dev-python-packages',
        'type': 'python_packages'},
    {   'install': [   'build-essential',
                       'curl',
                       'wget',
                       'git',
                       'vim',
                       'htop',
                       'ncdu'],
        'name': 'core',
        'post_install': 'echo "Core packages installed"\n',
        'pre_install': 'sudo apt update && sudo apt dist-upgrade -y\n',
        'type': 'debian_packages'},
    {   'install': ['python3', 'python3-pip', 'python3-venv'],
        'name': 'python',
        'type': 'debian_packages'},
    {   'install': ['pip', 'wheel', 'virtualenv'],
        'name': 'python-packages',
        'type': 'python_packages'}]

# ============================================================================
# OPERATION REGISTRY (Data-driven operations)
# ============================================================================

class OperationRegistry:
    """Central registry for all operations with data-driven execution."""

    # Package manager specifications
    PKG_MANAGERS = {
        'debian_packages': {
            'install_cmd': lambda pkgs: ["sudo", "apt-get", "install", "-y"] + pkgs,
            'uninstall_cmd': lambda pkgs: ["sudo", "apt-get", "remove", "-y"] + pkgs,
            'purge_cmd': lambda pkgs: ["sudo", "apt-get", "purge", "-y"] + pkgs,
            'batch': True,
        },
        'python_packages': {
            'install_cmd': lambda pkgs: [sys.executable, "-m", "pip", "install"] + pkgs,
            'uninstall_cmd': lambda pkgs: [sys.executable, "-m", "pip", "uninstall", "-y"] + pkgs,
            'batch': True,
        },
        'ruby_packages': {
            'install_cmd': lambda pkg: ["gem", "install", pkg],
            'uninstall_cmd': lambda pkg: ["gem", "uninstall", "-x", pkg],
            'batch': False,
        },
        'rust_packages': {
            'install_cmd': lambda pkg: ["cargo", "install", pkg],
            'uninstall_cmd': lambda pkg: ["cargo", "uninstall", pkg],
            'batch': False,
        },
        'homebrew_packages': {
            'install_cmd': lambda pkgs: ["brew", "install"] + pkgs,
            'uninstall_cmd': lambda pkgs: ["brew", "uninstall"] + pkgs,
            'batch': True,
        },
        'winget_packages': {
            'install_cmd': lambda pkg: ["winget", "install", pkg],
            'uninstall_cmd': lambda pkg: ["winget", "uninstall", pkg],
            'batch': False,
        },
        'chocolatey_packages': {
            'install_cmd': lambda pkgs: ["choco", "install", "-y"] + pkgs,
            'uninstall_cmd': lambda pkgs: ["choco", "uninstall", "-y"] + pkgs,
            'batch': True,
        },
        'shell': {
            'install_cmd': lambda script: script,
            'batch': None,  # N/A for shell
        },
        'powershell': {
            'install_cmd': lambda script: script,
            'batch': None,  # N/A for powershell
        },
    }

    # File operation specifications
    FILE_OPS = {
        'copy': {
            'check': lambda src, dst: src.exists(),
            'exec': lambda src, dst: shutil.copytree(src, dst) if src.is_dir()
                                      else shutil.copy2(src, dst),
            'prep': lambda src, dst: shutil.rmtree(dst) if dst.exists() and src.is_dir() else None,
        },
        'remove': {
            'check': lambda path: path.exists(),
            'exec': lambda path: shutil.rmtree(path) if path.is_dir() else path.unlink(),
        },
        'backup': {
            'check': lambda path: path.exists(),
            'exec': lambda src, dst: shutil.copytree(src, dst, dirs_exist_ok=True) if src.is_dir()
                                      else shutil.copy2(src, dst),
        },
    }

    # UI/Display specifications
    UI = {
        'colors': {
            'header': '\033[95m',
            'info': '\033[96m',
            'success': '\033[92m',
            'warning': '\033[93m',
            'error': '\033[91m',
            'end': '\033[0m',
        },
        'labels': {
            'info': '[INFO]',
            'success': '[OK]',
            'warning': '[WARN]',
            'error': '[ERROR]',
        },
    }

# ============================================================================
# EXECUTION ENGINE
# ============================================================================

class Executor:
    """Unified execution engine that consumes operation data."""

    def __init__(self, dry_run: bool = False, verbose: bool = False):
        self.dry_run = dry_run
        self.verbose = verbose
        self.registry = OperationRegistry()

    def log(self, msg: str, level: str = 'info') -> None:
        """Unified logging driven by UI data."""
        if level == 'header':
            print()
            colors = self.registry.UI['colors']
            print(f"{colors['header']}{msg}{colors['end']}")
            print("=" * 60)
        else:
            colors = self.registry.UI['colors']
            labels = self.registry.UI['labels']
            color = colors.get(level, colors['info'])
            label = labels.get(level, '')
            print(f"{color}{label}{colors['end']} {msg}")

    def run_cmd(self, cmd: Union[str, List[str]], description: str,
                shell: bool = False, check: bool = True) -> Optional[int]:
        """Execute command with standardized handling."""
        if self.dry_run:
            cmd_str = cmd if shell else ' '.join(cmd)
            self.log(f"[DRY-RUN] Would execute: {cmd_str}", 'info')
            return None

        self.log(f"{description}...", 'info')
        try:
            result = subprocess.run(
                cmd, shell=shell, check=check,
                capture_output=False, text=True
            )
            if result.returncode == 0:
                self.log(f"{description} completed", 'success')
            return result.returncode
        except subprocess.CalledProcessError as e:
            self.log(f"{description} failed with exit code {e.returncode}", 'error')
            if check:
                raise
            return e.returncode
        except FileNotFoundError:
            cmd_name = cmd[0] if isinstance(cmd, list) else cmd.split()[0]
            self.log(f"Command not found: {cmd_name}", 'error')
            if check:
                raise
            return 127

    def exec_file_op(self, op_type: str, **kwargs) -> None:
        """Execute file operation driven by FILE_OPS data."""
        op_spec = self.registry.FILE_OPS[op_type]

        if op_type == 'copy':
            src, dst, name = kwargs['src'], kwargs['dst'], kwargs['name']
            backup = kwargs.get('backup', True)

            if self.dry_run:
                if dst.exists() and backup:
                    self.log(f"[DRY-RUN] Would backup existing {dst}", 'info')
                self.log(f"[DRY-RUN] Would copy {src} to {dst}", 'info')
                return

            if not op_spec['check'](src, dst):
                self.log(f"Source not found: {src}", 'warning')
                return

            if backup and dst.exists():
                self.exec_file_op('backup', src=dst, name=name)

            self.log(f"Installing {name}", 'info')
            try:
                if op_spec['prep']:
                    op_spec['prep'](src, dst)
                op_spec['exec'](src, dst)
                self.log(f"Installed {name}", 'success')
            except (OSError, shutil.Error) as e:
                self.log(f"Failed to copy {name}: {e}", 'error')

        elif op_type == 'remove':
            path, name = kwargs['path'], kwargs['name']

            if self.dry_run:
                self.log(f"[DRY-RUN] Would remove {path}", 'info')
                return

            if not op_spec['check'](path):
                if self.verbose:
                    self.log(f"Not found: {path}", 'warning')
                return

            self.log(f"Removing {name}", 'info')
            try:
                op_spec['exec'](path)
                self.log(f"Removed {name}", 'success')
            except (OSError, shutil.Error) as e:
                self.log(f"Failed to remove {name}: {e}", 'error')

        elif op_type == 'backup':
            src, name = kwargs['src'], kwargs['name']

            if not op_spec['check'](src):
                return

            # Initialize backup directory if needed
            if PATHS['backup_dir'] is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                PATHS['backup_dir'] = PATHS['home_dir'] / f".dotfiles_backup_{timestamp}"

            dst = PATHS['backup_dir'] / name

            if self.dry_run:
                self.log(f"[DRY-RUN] Would backup {src} to {dst}", 'info')
                return

            if self.verbose:
                self.log(f"Backing up existing {src}", 'info')

            try:
                dst.parent.mkdir(parents=True, exist_ok=True)
                op_spec['exec'](src, dst)
                if self.verbose:
                    self.log(f"Backed up to {dst}", 'success')
            except (OSError, shutil.Error) as e:
                self.log(f"Failed to backup {name}: {e}", 'warning')

    def exec_section(self, section: Dict[str, Any], action: str) -> None:
        """Execute section operation driven by PKG_MANAGERS data."""
        section_type = section['type']
        section_name = section['name']

        if action == 'install':
            self.log(f"Section: {section_name}", 'header')

            # Pre-install hook
            if section.get('pre_install'):
                self.log("Running pre-install scripts...", 'info')
                self.run_cmd(section['pre_install'], "Pre-install", shell=True)

            # Main installation
            install_list = section.get('install', [])

            if section_type == 'shell' or section_type == 'powershell':
                self.log("Executing shell commands...", 'info')
                self.run_cmd(install_list, section_name, shell=True)
            elif section_type in self.registry.PKG_MANAGERS and install_list:
                mgr = self.registry.PKG_MANAGERS[section_type]

                if mgr['batch']:
                    cmd = mgr['install_cmd'](install_list)
                    self.run_cmd(cmd, f"Installing {section_name} packages")
                else:
                    for package in install_list:
                        cmd = mgr['install_cmd'](package)
                        self.run_cmd(cmd, f"Installing {package}")

            # Purge packages (if specified)
            if section.get('purge') and 'purge_cmd' in self.registry.PKG_MANAGERS.get(section_type, {}):
                self.log("Purging unwanted packages...", 'info')
                mgr = self.registry.PKG_MANAGERS[section_type]
                cmd = mgr['purge_cmd'](section['purge'])
                self.run_cmd(cmd, f"Purging {section_name} packages")

            # Post-install hook
            if section.get('post_install'):
                self.log("Running post-install scripts...", 'info')
                self.run_cmd(section['post_install'], "Post-install", shell=True)

        elif action == 'uninstall':
            self.log(f"Uninstalling: {section_name}", 'header')

            if section_type == 'shell' or section_type == 'powershell':
                self.log("Shell sections cannot be automatically uninstalled", 'warning')
                return

            install_list = section.get('install', [])
            if section_type in self.registry.PKG_MANAGERS and install_list:
                mgr = self.registry.PKG_MANAGERS[section_type]
                packages = [re.split(r'[=<>:@~!]+', pkg)[0] for pkg in install_list]

                if mgr['batch']:
                    cmd = mgr['uninstall_cmd'](packages)
                    self.run_cmd(cmd, f"Uninstalling {section_name} packages", check=False)
                else:
                    for package in packages:
                        cmd = mgr['uninstall_cmd'](package)
                        self.run_cmd(cmd, f"Uninstalling {package}", check=False)

    def exec_file_set(self, file_set_name: str, action: str, **kwargs) -> None:
        """Execute file set operations driven by FILE_SETS data."""
        file_list = FILE_SETS.get(file_set_name, [])

        if file_set_name == 'defaults':
            src_dir = PATHS['default_dir']
            dst_dir = PATHS['home_dir']
            header = "default dotfiles"
        elif file_set_name == 'configs':
            src_dir = PATHS['config_dir']
            dst_dir = PATHS['config_dst']
            header = ".config folders"
        else:
            return

        if action == 'install':
            self.log(f"Installing {header}", 'header')

            if not src_dir or not src_dir.exists():
                if file_set_name == 'defaults' or self.verbose:
                    self.log(f"Source directory not found: {src_dir}", 'warning')
                return

            if not self.dry_run and file_set_name == 'configs' and not dst_dir.exists():
                dst_dir.mkdir(parents=True, exist_ok=True)

            for entry in file_list:
                src = src_dir / entry
                dst = dst_dir / entry
                self.exec_file_op('copy', src=src, dst=dst, name=entry,
                                backup=kwargs.get('backup', True))

        elif action == 'uninstall':
            self.log(f"Uninstalling {header}", 'header')

            for entry in file_list:
                dst = dst_dir / entry
                self.exec_file_op('remove', path=dst, name=entry)

# ============================================================================
# HIGH-LEVEL WORKFLOW (Data-driven orchestration)
# ============================================================================

WORKFLOWS = {
    'install': {
        'header': lambda: f"Installing: {RECIPE['name']}",
        'steps': [
            {
                'type': 'info_display',
                'data': lambda: [
                    f"Platform: {RECIPE['platform']}",
                    f"OS: {RECIPE['os']} {RECIPE['version']} ({RECIPE['release']})",
                ],
            },
            {
                'type': 'file_set',
                'name': 'defaults',
                'action': 'install',
            },
            {
                'type': 'file_set',
                'name': 'configs',
                'action': 'install',
            },
            {
                'type': 'sections',
                'action': 'install',
                'reverse': False,
            },
            {
                'type': 'summary',
                'message': "Installation complete!",
            },
        ],
    },
    'uninstall': {
        'header': lambda: f"Uninstalling: {RECIPE['name']}",
        'steps': [
            {
                'type': 'info_display',
                'data': lambda: [
                    f"Platform: {RECIPE['platform']}",
                    f"OS: {RECIPE['os']} {RECIPE['version']} ({RECIPE['release']})",
                ],
            },
            {
                'type': 'sections',
                'action': 'uninstall',
                'reverse': True,
            },
            {
                'type': 'file_set',
                'name': 'configs',
                'action': 'uninstall',
            },
            {
                'type': 'file_set',
                'name': 'defaults',
                'action': 'uninstall',
            },
            {
                'type': 'summary',
                'message': "Uninstallation complete!",
            },
        ],
    },
}

def run_workflow(workflow_name: str, executor: Executor, **kwargs) -> None:
    """Execute workflow driven by WORKFLOWS data."""
    workflow = WORKFLOWS[workflow_name]

    # Display header
    executor.log(workflow['header'](), 'header')

    # Execute steps
    for step in workflow['steps']:
        step_type = step['type']

        if step_type == 'info_display':
            messages = step['data']()
            for msg in messages:
                executor.log(msg, 'info')
            print()

            # Backup notice for install workflow
            if workflow_name == 'install':
                if kwargs.get('backup', True):
                    executor.log("Backup enabled: existing files will be backed up before overwriting", 'info')
                else:
                    executor.log("Backup disabled: existing files will be overwritten without backup", 'warning')

        elif step_type == 'file_set':
            executor.exec_file_set(step['name'], step['action'], **kwargs)

        elif step_type == 'sections':
            sections = reversed(SECTIONS) if step['reverse'] else SECTIONS
            for section in sections:
                executor.exec_section(section, step['action'])

        elif step_type == 'summary':
            print()
            if workflow_name == 'install' and PATHS['backup_dir'] and PATHS['backup_dir'].exists():
                executor.log(f"Backups saved to: {PATHS['backup_dir']}", 'info')
            executor.log(step['message'], 'success')

# ============================================================================
# CLI INTERFACE
# ============================================================================

def main():
    """Main entry point with argparse interface."""
    parser = argparse.ArgumentParser(
        description=f"Setup script for {RECIPE['name']}",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s install                 # Install all packages and files (with backup)
  %(prog)s uninstall               # Uninstall all packages and files
  %(prog)s install --dry-run       # Show what would be installed
  %(prog)s install --verbose       # Verbose output with backup details
  %(prog)s install --no-backup     # Install without backing up existing files
  %(prog)s uninstall --dry-run -v  # Show what would be uninstalled

Note: By default, existing dotfiles and config files are backed up to
      ~/.dotfiles_backup_<timestamp>/ before being overwritten.
        """
    )

    parser.add_argument(
        'action',
        choices=['install', 'uninstall'],
        help='Action to perform'
    )
    parser.add_argument(
        '-n', '--dry-run',
        action='store_true',
        help='Show what would be done without executing'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    parser.add_argument(
        '--no-backup',
        action='store_true',
        help='Skip backing up existing files (default: backup enabled)'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f"%(prog)s for {RECIPE['name']} ({RECIPE['platform']}/{RECIPE['os']})"
    )

    args = parser.parse_args()

    # Platform compatibility check
    current_platform = platform.system().lower()
    current_platform = 'darwin' if current_platform == 'darwin' else current_platform

    executor = Executor(dry_run=args.dry_run, verbose=args.verbose)

    if args.verbose:
        executor.log(f"Current platform: {current_platform}", 'info')
        executor.log(f"Target platform: {RECIPE['platform']}", 'info')

    if current_platform != RECIPE['platform'] and not args.dry_run:
        executor.log(f"Platform mismatch: running on {current_platform}, "
                    f"but recipe is for {RECIPE['platform']}", 'warning')
        response = input("Continue anyway? [y/N]: ")
        if response.lower() != 'y':
            executor.log("Aborted", 'info')
            sys.exit(0)

    # Execute workflow
    try:
        if args.action == 'install':
            run_workflow('install', executor, backup=not args.no_backup)
        elif args.action == 'uninstall':
            if not args.dry_run:
                executor.log("This will remove installed packages and files!", 'warning')
                response = input("Are you sure? [y/N]: ")
                if response.lower() != 'y':
                    executor.log("Aborted", 'info')
                    sys.exit(0)
            run_workflow('uninstall', executor)
    except KeyboardInterrupt:
        print()
        executor.log("Interrupted by user", 'warning')
        sys.exit(130)
    except Exception as e:
        executor.log(f"Unexpected error: {e}", 'error')
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()