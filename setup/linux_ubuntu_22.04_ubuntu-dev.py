#!/usr/bin/env python3
"""
Setup script for ubuntu-dev
Platform: linux
OS: ubuntu 22.04

Generated by start-vm
Python 3.8+ compatible, uses only standard library
"""

import argparse
import platform
import re
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Optional

# Recipe metadata
RECIPE_NAME = "ubuntu-dev"
PLATFORM = "linux"
OS_NAME = "ubuntu"
OS_VERSION = "22.04"
OS_RELEASE = "jammy"

# Paths
CONFIG_DIR = Path("config") / "" if "" else None
DEFAULT_DIR = Path("default")
HOME_DIR = Path.home()
CONFIG_DST = HOME_DIR / ".config"

# Backup directory (will be set dynamically with timestamp)
BACKUP_DIR = None

# Default files to install
DEFAULT_FILES = [
    ".fonts",
    "bin",
    ".vimrc-heavy",
    ".bashrc",
    ".SciTEUser.properties",
    ".xinitrc",
    ".gtkrc-2.0",
    ".vimrc",
    ".ghci",
    "src",
]

# Config files to install
CONFIG_FILES = [
]

# Section definitions
SECTIONS = [
    {
    "name": "dev-tools",
    "type": "debian_packages",
    "install": [
        "nodejs",
        "npm",
        "docker.io",
        "postgresql-client",
    ],
    },
    {
    "name": "dev-python-packages",
    "type": "python_packages",
    "install": [
        "pytest",
        "black",
        "pylint",
        "ipython",
        "jupyter",
    ],
    },
    {
    "name": "core",
    "type": "debian_packages",
    "pre_install": """sudo apt update && sudo apt dist-upgrade -y
""",
    "install": [
        "build-essential",
        "curl",
        "wget",
        "git",
        "vim",
        "htop",
        "ncdu",
    ],
    "post_install": """echo "Core packages installed"
""",
    },
    {
    "name": "python",
    "type": "debian_packages",
    "install": [
        "python3",
        "python3-pip",
        "python3-venv",
    ],
    },
    {
    "name": "python-packages",
    "type": "python_packages",
    "install": [
        "pip",
        "wheel",
        "virtualenv",
    ],
    },
]

# Color codes
_COLORS = {
    'header': '\033[95m',
    'info': '\033[96m',
    'success': '\033[92m',
    'warning': '\033[93m',
    'error': '\033[91m',
    'end': '\033[0m'
}

_LABELS = {
    'info': '[INFO]',
    'success': '[OK]',
    'warning': '[WARN]',
    'error': '[ERROR]'
}


def _print(msg: str, level: str = 'info') -> None:
    """Print formatted message."""
    if level == 'header':
        print()
        print(f"{_COLORS['header']}{msg}{_COLORS['end']}")
        print("=" * 60)
    else:
        label = _LABELS.get(level, '')
        color = _COLORS.get(level, _COLORS['info'])
        print(f"{color}{label}{_COLORS['end']} {msg}")


# Convenience wrappers
print_header = lambda msg: _print(msg, 'header')
print_info = lambda msg: _print(msg, 'info')
print_success = lambda msg: _print(msg, 'success')
print_warning = lambda msg: _print(msg, 'warning')
print_error = lambda msg: _print(msg, 'error')


def run_command(cmd: List[str], description: str, dry_run: bool = False,
                check: bool = True, shell: bool = False) -> Optional[int]:
    """
    Execute a command with error handling.

    Args:
        cmd: Command to execute (list or string if shell=True)
        description: Description of what command does
        dry_run: If True, only print command without executing
        check: If True, raise exception on non-zero exit
        shell: If True, run command in shell

    Returns:
        Exit code or None if dry_run
    """
    if dry_run:
        cmd_str = cmd if shell else ' '.join(cmd)
        print_info(f"[DRY-RUN] Would execute: {cmd_str}")
        return None

    print_info(f"{description}...")
    try:
        if shell:
            result = subprocess.run(cmd, shell=True, check=check,
                                  capture_output=False, text=True)
        else:
            result = subprocess.run(cmd, check=check, capture_output=False, text=True)

        if result.returncode == 0:
            print_success(f"{description} completed")
        return result.returncode
    except subprocess.CalledProcessError as e:
        print_error(f"{description} failed with exit code {e.returncode}")
        if check:
            raise
        return e.returncode
    except FileNotFoundError:
        print_error(f"Command not found: {cmd[0] if isinstance(cmd, list) else cmd}")
        if check:
            raise
        return 127


def backup_file_or_dir(path: Path, name: str, dry_run: bool = False,
                        verbose: bool = False) -> None:
    """Backup existing file or directory before overwriting."""
    global BACKUP_DIR

    if not path.exists():
        return  # Nothing to backup

    if BACKUP_DIR is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        BACKUP_DIR = HOME_DIR / f".dotfiles_backup_{timestamp}"

    backup_path = BACKUP_DIR / name

    if dry_run:
        print_info(f"[DRY-RUN] Would backup {path} to {backup_path}")
        return

    if verbose:
        print_info(f"Backing up existing {path}")

    try:
        # Create backup directory if it doesn't exist
        backup_path.parent.mkdir(parents=True, exist_ok=True)

        if path.is_dir():
            shutil.copytree(path, backup_path, dirs_exist_ok=True)
        else:
            shutil.copy2(path, backup_path)

        if verbose:
            print_success(f"Backed up to {backup_path}")
    except (OSError, shutil.Error) as e:
        print_warning(f"Failed to backup {name}: {e}")


def copy_file_or_dir(src: Path, dst: Path, name: str, dry_run: bool = False,
                     verbose: bool = False, backup: bool = True) -> None:
    """Copy a file or directory with error handling."""
    if dry_run:
        if dst.exists() and backup:
            print_info(f"[DRY-RUN] Would backup existing {dst}")
        print_info(f"[DRY-RUN] Would copy {src} to {dst}")
        return

    if not src.exists():
        print_warning(f"Source not found: {src}")
        return

    # Backup existing file/dir if requested
    if backup and dst.exists():
        backup_file_or_dir(dst, name, dry_run, verbose)

    print_info(f"Installing {name}")
    if dst.exists() and verbose:
        print_warning(f"Overwriting existing {dst}")

    try:
        if src.is_dir():
            if dst.exists():
                shutil.rmtree(dst)
            shutil.copytree(src, dst)
        else:
            shutil.copy2(src, dst)
        print_success(f"Installed {name}")
    except (OSError, shutil.Error) as e:
        print_error(f"Failed to copy {name}: {e}")


def remove_file_or_dir(path: Path, name: str, dry_run: bool = False,
                       verbose: bool = False) -> None:
    """Remove a file or directory with error handling."""
    if dry_run:
        print_info(f"[DRY-RUN] Would remove {path}")
        return

    if not path.exists():
        if verbose:
            print_warning(f"Not found: {path}")
        return

    print_info(f"Removing {name}")
    try:
        if path.is_dir():
            shutil.rmtree(path)
        else:
            path.unlink()
        print_success(f"Removed {name}")
    except (OSError, shutil.Error) as e:
        print_error(f"Failed to remove {name}: {e}")


def install_default_files(dry_run: bool = False, verbose: bool = False,
                          backup: bool = True) -> None:
    """Install default dotfiles to home directory."""
    print_header("Installing default dotfiles")

    if not DEFAULT_DIR.exists():
        print_warning(f"Default directory not found: {DEFAULT_DIR}")
        return

    for entry in DEFAULT_FILES:
        src = DEFAULT_DIR / entry
        dst = HOME_DIR / entry
        copy_file_or_dir(src, dst, entry, dry_run, verbose, backup)


def install_config_files(dry_run: bool = False, verbose: bool = False,
                         backup: bool = True) -> None:
    """Install config files to .config directory."""
    print_header("Installing .config folders")

    if not CONFIG_DIR or not CONFIG_DIR.exists():
        if verbose:
            print_warning(f"Config directory not found: {CONFIG_DIR}")
        return

    if not dry_run and not CONFIG_DST.exists():
        CONFIG_DST.mkdir(parents=True, exist_ok=True)

    for entry in CONFIG_FILES:
        src = CONFIG_DIR / entry
        dst = CONFIG_DST / entry
        copy_file_or_dir(src, dst, entry, dry_run, verbose, backup)


def uninstall_default_files(dry_run: bool = False, verbose: bool = False) -> None:
    """Uninstall default dotfiles from home directory."""
    print_header("Uninstalling default dotfiles")

    for entry in DEFAULT_FILES:
        dst = HOME_DIR / entry
        remove_file_or_dir(dst, entry, dry_run, verbose)


def uninstall_config_files(dry_run: bool = False, verbose: bool = False) -> None:
    """Uninstall config files from .config directory."""
    print_header("Uninstalling .config folders")

    for entry in CONFIG_FILES:
        dst = CONFIG_DST / entry
        remove_file_or_dir(dst, entry, dry_run, verbose)


def strip_version_spec(package: str) -> str:
    """Strip version specifier from package name."""
    return re.split(r'[=<>:@~!]+', package)[0]


# Package manager configurations
_PKG_MANAGERS = {
    'debian_packages': {
        'install': lambda pkgs: ["sudo", "apt-get", "install", "-y"] + pkgs,
        'uninstall': lambda pkgs: ["sudo", "apt-get", "remove", "-y"] + pkgs,
        'batch': True
    },
    'python_packages': {
        'install': lambda pkgs: [sys.executable, "-m", "pip", "install"] + pkgs,
        'uninstall': lambda pkgs: [sys.executable, "-m", "pip", "uninstall", "-y"] + pkgs,
        'batch': True
    },
    'ruby_packages': {
        'install': lambda pkg: ["gem", "install", pkg],
        'uninstall': lambda pkg: ["gem", "uninstall", "-x", pkg],
        'batch': False
    },
    'rust_packages': {
        'install': lambda pkg: ["cargo", "install", pkg],
        'uninstall': lambda pkg: ["cargo", "uninstall", pkg],
        'batch': False
    },
    'homebrew_packages': {
        'install': lambda pkgs: ["brew", "install"] + pkgs,
        'uninstall': lambda pkgs: ["brew", "uninstall"] + pkgs,
        'batch': True
    }
}


def install_section(section: dict, dry_run: bool = False, verbose: bool = False) -> None:
    """Install a section based on its type."""
    print_header(f"Section: {section['name']}")

    # Pre-install scripts
    if section.get('pre_install'):
        print_info("Running pre-install scripts...")
        run_command(section['pre_install'], "Pre-install", dry_run=dry_run, shell=True)

    section_type = section['type']
    install_list = section.get('install', [])

    # Handle shell sections
    if section_type == 'shell':
        print_info("Executing shell commands...")
        run_command(install_list, section['name'], dry_run=dry_run, shell=True)

    # Handle package manager sections
    elif section_type in _PKG_MANAGERS and install_list:
        mgr = _PKG_MANAGERS[section_type]
        if mgr['batch']:
            cmd = mgr['install'](install_list)
            run_command(cmd, f"Installing {section['name']} packages", dry_run=dry_run)
        else:
            for package in install_list:
                cmd = mgr['install'](package)
                run_command(cmd, f"Installing {package}", dry_run=dry_run)

    # Purge packages (debian only)
    if section.get('purge') and section_type == 'debian_packages':
        print_info("Purging unwanted packages...")
        run_command(["sudo", "apt-get", "purge", "-y"] + section['purge'],
                   f"Purging {section['name']} packages", dry_run=dry_run)

    # Post-install scripts
    if section.get('post_install'):
        print_info("Running post-install scripts...")
        run_command(section['post_install'], "Post-install", dry_run=dry_run, shell=True)


def uninstall_section(section: dict, dry_run: bool = False, verbose: bool = False) -> None:
    """Uninstall a section based on its type."""
    print_header(f"Uninstalling: {section['name']}")

    section_type = section['type']
    install_list = section.get('install', [])

    # Handle shell sections
    if section_type == 'shell':
        print_warning("Shell sections cannot be automatically uninstalled")
        return

    # Handle package manager sections
    if section_type in _PKG_MANAGERS and install_list:
        mgr = _PKG_MANAGERS[section_type]
        packages = [strip_version_spec(pkg) for pkg in install_list]

        if mgr['batch']:
            cmd = mgr['uninstall'](packages)
            run_command(cmd, f"Uninstalling {section['name']} packages",
                       dry_run=dry_run, check=False)
        else:
            for package in packages:
                cmd = mgr['uninstall'](package)
                run_command(cmd, f"Uninstalling {package}", dry_run=dry_run, check=False)


def install_all(dry_run: bool = False, verbose: bool = False,
                backup: bool = True) -> None:
    """Run full installation."""
    print_header(f"Installing: {RECIPE_NAME}")
    print_info(f"Platform: {PLATFORM}")
    print_info(f"OS: {OS_NAME} {OS_VERSION} ({OS_RELEASE})")
    print()

    if backup:
        print_info("Backup enabled: existing files will be backed up before overwriting")
    else:
        print_warning("Backup disabled: existing files will be overwritten without backup")

    # Install default files
    install_default_files(dry_run, verbose, backup)

    # Install config files
    install_config_files(dry_run, verbose, backup)

    # Install sections
    for section in SECTIONS:
        install_section(section, dry_run, verbose)

    print()
    if backup and BACKUP_DIR and BACKUP_DIR.exists():
        print_info(f"Backups saved to: {BACKUP_DIR}")
    print_success("Installation complete!")


def uninstall_all(dry_run: bool = False, verbose: bool = False) -> None:
    """Run full uninstallation."""
    print_header(f"Uninstalling: {RECIPE_NAME}")
    print_info(f"Platform: {PLATFORM}")
    print_info(f"OS: {OS_NAME} {OS_VERSION} ({OS_RELEASE})")
    print()

    # Uninstall sections (in reverse order)
    for section in reversed(SECTIONS):
        uninstall_section(section, dry_run, verbose)

    # Uninstall config files
    uninstall_config_files(dry_run, verbose)

    # Uninstall default files
    uninstall_default_files(dry_run, verbose)

    print()
    print_success("Uninstallation complete!")


def main():
    """Main entry point with argparse interface."""
    parser = argparse.ArgumentParser(
        description=f"Setup script for {RECIPE_NAME}",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s install                 # Install all packages and files (with backup)
  %(prog)s uninstall               # Uninstall all packages and files
  %(prog)s install --dry-run       # Show what would be installed
  %(prog)s install --verbose       # Verbose output with backup details
  %(prog)s install --no-backup     # Install without backing up existing files
  %(prog)s uninstall --dry-run -v  # Show what would be uninstalled

Note: By default, existing dotfiles and config files are backed up to
      ~/.dotfiles_backup_<timestamp>/ before being overwritten.
        """
    )

    parser.add_argument(
        'action',
        choices=['install', 'uninstall'],
        help='Action to perform'
    )
    parser.add_argument(
        '-n', '--dry-run',
        action='store_true',
        help='Show what would be done without executing'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    parser.add_argument(
        '--no-backup',
        action='store_true',
        help='Skip backing up existing files (default: backup enabled)'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s for {RECIPE_NAME} ({PLATFORM}/{OS_NAME})'
    )

    args = parser.parse_args()

    # Check platform compatibility
    current_platform = platform.system().lower()
    current_platform = 'darwin' if current_platform == 'darwin' else current_platform

    if args.verbose:
        print_info(f"Current platform: {current_platform}")
        print_info(f"Target platform: {PLATFORM}")

    if current_platform != PLATFORM and not args.dry_run:
        print_warning(f"Platform mismatch: running on {current_platform}, "
                     f"but recipe is for {PLATFORM}")
        response = input("Continue anyway? [y/N]: ")
        if response.lower() != 'y':
            print_info("Aborted")
            sys.exit(0)

    # Execute requested action
    try:
        if args.action == 'install':
            install_all(args.dry_run, args.verbose, backup=not args.no_backup)
        elif args.action == 'uninstall':
            if not args.dry_run:
                print_warning("This will remove installed packages and files!")
                response = input("Are you sure? [y/N]: ")
                if response.lower() != 'y':
                    print_info("Aborted")
                    sys.exit(0)
            uninstall_all(args.dry_run, args.verbose)
    except KeyboardInterrupt:
        print()
        print_warning("Interrupted by user")
        sys.exit(130)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()