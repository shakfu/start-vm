#!/usr/bin/env bash
#
# Setup script for ubuntu-base
# Platform: linux
# OS: ubuntu 22.04
#
# Generated by start-vm
#

set -e  # Exit on error

# Colors
COLOR_HEADER="\033[1;35m"
COLOR_INFO="\033[1;36m"
COLOR_SUCCESS="\033[1;32m"
COLOR_WARNING="\033[1;33m"
COLOR_ERROR="\033[1;31m"
COLOR_RESET="\033[0m"

# Paths
CONFIG_DIR="config/ubuntu"
DEFAULT_DIR="default"
CONFIG_DST="$HOME/.config"

# Recipe metadata
RECIPE_NAME="ubuntu-base"
PLATFORM="linux"
OS_NAME="ubuntu"
OS_VERSION="22.04"
OS_RELEASE="jammy"

# Default files to install
DEFAULT_FILES=(
    ".fonts"
    "bin"
    ".vimrc-heavy"
    ".bashrc"
    ".SciTEUser.properties"
    ".xinitrc"
    ".gtkrc-2.0"
    ".vimrc"
    ".ghci"
    "src"
)

# Config files to install
CONFIG_FILES=(
)

# Options
DRY_RUN=false
VERBOSE=false
BACKUP=true
ACTION=""

# Backup directory (will be set dynamically with timestamp)
BACKUP_DIR=""

print_header() {
    echo
    echo -e "${COLOR_HEADER}$1${COLOR_RESET}"
    echo "============================================================"
}

print_info() {
    echo -e "${COLOR_INFO}[INFO]${COLOR_RESET} $1"
}

print_success() {
    echo -e "${COLOR_SUCCESS}[OK]${COLOR_RESET} $1"
}

print_warning() {
    echo -e "${COLOR_WARNING}[WARN]${COLOR_RESET} $1"
}

print_error() {
    echo -e "${COLOR_ERROR}[ERROR]${COLOR_RESET} $1"
}

run_command() {
    local description="$1"
    shift
    local cmd="$*"

    if [ "$DRY_RUN" = true ]; then
        print_info "[DRY-RUN] Would execute: $cmd"
        return 0
    fi

    print_info "$description..."
    if eval "$cmd"; then
        print_success "$description completed"
        return 0
    else
        print_error "$description failed"
        return 1
    fi
}

backup_file_or_dir() {
    local path="$1"
    local name="$2"

    if [ ! -e "$path" ]; then
        return 0  # Nothing to backup
    fi

    if [ -z "$BACKUP_DIR" ]; then
        BACKUP_DIR="$HOME/.dotfiles_backup_$(date +%Y%m%d_%H%M%S)"
    fi

    local backup_path="$BACKUP_DIR/$name"

    if [ "$DRY_RUN" = true ]; then
        print_info "[DRY-RUN] Would backup $path to $backup_path"
        return 0
    fi

    if [ "$VERBOSE" = true ]; then
        print_info "Backing up existing $path"
    fi

    # Create backup directory structure
    mkdir -p "$(dirname "$backup_path")"

    if cp -rf "$path" "$backup_path"; then
        if [ "$VERBOSE" = true ]; then
            print_success "Backed up to $backup_path"
        fi
        return 0
    else
        print_warning "Failed to backup $name"
        return 1
    fi
}

copy_file_or_dir() {
    local src="$1"
    local dst="$2"
    local name="$3"

    if [ "$DRY_RUN" = true ]; then
        if [ -e "$dst" ] && [ "$BACKUP" = true ]; then
            print_info "[DRY-RUN] Would backup existing $dst"
        fi
        print_info "[DRY-RUN] Would copy $src to $dst"
        return 0
    fi

    if [ ! -e "$src" ]; then
        print_warning "Source not found: $src"
        return 0
    fi

    # Backup existing file/dir if requested
    if [ "$BACKUP" = true ] && [ -e "$dst" ]; then
        backup_file_or_dir "$dst" "$name"
    fi

    print_info "Installing $name"
    if [ "$VERBOSE" = true ] && [ -e "$dst" ]; then
        print_warning "Overwriting existing $dst"
    fi

    if cp -rf "$src" "$dst"; then
        print_success "Installed $name"
    else
        print_error "Failed to copy $name"
        return 1
    fi
}

remove_file_or_dir() {
    local path="$1"
    local name="$2"

    if [ "$DRY_RUN" = true ]; then
        print_info "[DRY-RUN] Would remove $path"
        return 0
    fi

    if [ ! -e "$path" ]; then
        if [ "$VERBOSE" = true ]; then
            print_warning "Not found: $path"
        fi
        return 0
    fi

    print_info "Removing $name"
    if rm -rf "$path"; then
        print_success "Removed $name"
    else
        print_error "Failed to remove $name"
        return 1
    fi
}

strip_version_spec() {
    local package="$1"
    # Remove version specifiers
    echo "$package" | sed -E 's/(==|>=|<=|>|<|~=|!=|=|:|@).*//'
}

install_default_files() {
    print_header "Installing default dotfiles"

    if [ ! -d "$DEFAULT_DIR" ]; then
        print_warning "Default directory not found: $DEFAULT_DIR"
        return 0
    fi

    for entry in "${DEFAULT_FILES[@]}"; do
        copy_file_or_dir "$DEFAULT_DIR/$entry" "$HOME/$entry" "$entry"
    done
}

install_config_files() {
    print_header "Installing .config folders"

    if [ -z "ubuntu" ] || [ ! -d "$CONFIG_DIR" ]; then
        if [ "$VERBOSE" = true ]; then
            print_warning "Config directory not found: $CONFIG_DIR"
        fi
        return 0
    fi

    if [ ! -d "$CONFIG_DST" ]; then
        mkdir -p "$CONFIG_DST"
    fi

    for entry in "${CONFIG_FILES[@]}"; do
        copy_file_or_dir "$CONFIG_DIR/$entry" "$CONFIG_DST/$entry" "$entry"
    done
}

uninstall_default_files() {
    print_header "Uninstalling default dotfiles"

    for entry in "${DEFAULT_FILES[@]}"; do
        remove_file_or_dir "$HOME/$entry" "$entry"
    done
}

uninstall_config_files() {
    print_header "Uninstalling .config folders"

    for entry in "${CONFIG_FILES[@]}"; do
        remove_file_or_dir "$CONFIG_DST/$entry" "$entry"
    done
}

install_section_1() {
    print_header "Section: core"

    # Pre-install scripts
    print_info "Running pre-install scripts..."
    run_command "Pre-install" "sudo apt update \u0026\u0026 sudo apt dist-upgrade -y\n"

    # Install Debian packages
    run_command "Installing core debian packages" \
        "sudo apt-get install -y build-essential curl wget git vim htop ncdu "
    # Post-install scripts
    print_info "Running post-install scripts..."
    run_command "Post-install" "echo \"Core packages installed\"\n"
}

uninstall_section_1() {
    print_header "Uninstalling: core"

    # Uninstall Debian packages
    local packages=("$(strip_version_spec 'build-essential')" "$(strip_version_spec 'curl')" "$(strip_version_spec 'wget')" "$(strip_version_spec 'git')" "$(strip_version_spec 'vim')" "$(strip_version_spec 'htop')" "$(strip_version_spec 'ncdu')" )
    run_command "Uninstalling core debian packages" \
        "sudo apt-get remove -y ${packages[@]}" || true
}

install_section_2() {
    print_header "Section: python"

    # Install Debian packages
    run_command "Installing python debian packages" \
        "sudo apt-get install -y python3 python3-pip python3-venv "
}

uninstall_section_2() {
    print_header "Uninstalling: python"

    # Uninstall Debian packages
    local packages=("$(strip_version_spec 'python3')" "$(strip_version_spec 'python3-pip')" "$(strip_version_spec 'python3-venv')" )
    run_command "Uninstalling python debian packages" \
        "sudo apt-get remove -y ${packages[@]}" || true
}

install_section_3() {
    print_header "Section: python-packages"

    # Install Python packages
    run_command "Installing python-packages python packages" \
        "sudo -H pip3 install pip wheel virtualenv "
}

uninstall_section_3() {
    print_header "Uninstalling: python-packages"

    # Uninstall Python packages
    local packages=("$(strip_version_spec 'pip')" "$(strip_version_spec 'wheel')" "$(strip_version_spec 'virtualenv')" )
    run_command "Uninstalling python-packages python packages" \
        "sudo -H pip3 uninstall -y ${packages[@]}" || true
}

install_all() {
    print_header "Installing: $RECIPE_NAME"
    print_info "Platform: $PLATFORM"
    print_info "OS: $OS_NAME $OS_VERSION ($OS_RELEASE)"
    echo

    if [ "$BACKUP" = true ]; then
        print_info "Backup enabled: existing files will be backed up before overwriting"
    else
        print_warning "Backup disabled: existing files will be overwritten without backup"
    fi

    install_default_files
    install_config_files
    install_section_1
    install_section_2
    install_section_3
    echo
    if [ "$BACKUP" = true ] && [ -n "$BACKUP_DIR" ] && [ -d "$BACKUP_DIR" ]; then
        print_info "Backups saved to: $BACKUP_DIR"
    fi
    print_success "Installation complete!"
}

uninstall_all() {
    print_header "Uninstalling: $RECIPE_NAME"
    print_info "Platform: $PLATFORM"
    print_info "OS: $OS_NAME $OS_VERSION ($OS_RELEASE)"
    echo

    # Uninstall sections in reverse order
    uninstall_section_3
    uninstall_section_2
    uninstall_section_1
    uninstall_config_files
    uninstall_default_files

    echo
    print_success "Uninstallation complete!"
}

show_help() {
    cat << EOF
Usage: $0 <command> [options]

Commands:
    install     Install all packages and files
    uninstall   Uninstall all packages and files

Options:
    -n, --dry-run      Show what would be done without executing
    -v, --verbose      Enable verbose output
    --no-backup        Skip backing up existing files (default: backup enabled)
    -h, --help         Show this help message

Examples:
    $0 install                 # Install all packages and files (with backup)
    $0 uninstall               # Uninstall all packages and files
    $0 install --dry-run       # Show what would be installed
    $0 install --verbose       # Verbose output with backup details
    $0 install --no-backup     # Install without backing up existing files
    $0 uninstall --dry-run -v  # Show what would be uninstalled

Note: By default, existing dotfiles and config files are backed up to
      ~/.dotfiles_backup_<timestamp>/ before being overwritten.

Generated by start-vm for $RECIPE_NAME ($PLATFORM/$OS_NAME)
EOF
}

# Parse command line arguments
if [ $# -eq 0 ]; then
    show_help
    exit 1
fi

while [ $# -gt 0 ]; do
    case "$1" in
        install|uninstall)
            ACTION="$1"
            shift
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        --no-backup)
            BACKUP=false
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            echo "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Validate action
if [ -z "$ACTION" ]; then
    print_error "No command specified"
    show_help
    exit 1
fi

# Execute action
case "$ACTION" in
    install)
        install_all
        ;;
    uninstall)
        if [ "$DRY_RUN" = false ]; then
            print_warning "This will remove installed packages and files!"
            read -p "Are you sure? [y/N]: " -r
            echo
            if [[ ! $REPLY =~ ^[Yy]$ ]]; then
                print_info "Aborted"
                exit 0
            fi
        fi
        uninstall_all
        ;;
    *)
        print_error "Invalid command: $ACTION"
        show_help
        exit 1
        ;;
esac