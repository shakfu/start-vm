#
# Setup script for base
# Platform: windows
# OS: windows 11
#
# Generated by start-vm
#

param(
    [Parameter(Mandatory=$true, Position=0)]
    [ValidateSet('install', 'uninstall')]
    [string]$Action,

    [Alias('n')]
    [switch]$DryRun,

    [Alias('v')]
    [switch]$Verbose,

    [Alias('h')]
    [switch]$Help
)

# Set error action preference
$ErrorActionPreference = "Stop"

# Recipe metadata
$RECIPE_NAME = "base"
$PLATFORM = "windows"
$OS_NAME = "windows"
$OS_VERSION = "11"
$OS_RELEASE = "23H2"

# Paths
$CONFIG_DIR = "config\windows"
$DEFAULT_DIR = "default"
$CONFIG_DST = "$env:USERPROFILE\.config"

# Default files to install
$DEFAULT_FILES = @(
    ".fonts",
    "bin",
    ".vimrc-heavy",
    ".bashrc",
    ".SciTEUser.properties",
    ".xinitrc",
    ".gtkrc-2.0",
    ".vimrc",
    ".ghci",
    "src",
)

# Config files to install
$CONFIG_FILES = @(
)

function Write-Header {
    param([string]$Message)
    Write-Host ""
    Write-Host $Message -ForegroundColor Magenta
    Write-Host "============================================================"
}

function Write-Info {
    param([string]$Message)
    Write-Host "[INFO] $Message" -ForegroundColor Cyan
}

function Write-Success {
    param([string]$Message)
    Write-Host "[OK] $Message" -ForegroundColor Green
}

function Write-Warning {
    param([string]$Message)
    Write-Host "[WARN] $Message" -ForegroundColor Yellow
}

function Write-Error {
    param([string]$Message)
    Write-Host "[ERROR] $Message" -ForegroundColor Red
}

function Invoke-Command {
    param(
        [string]$Description,
        [scriptblock]$Command
    )

    if ($DryRun) {
        Write-Info "[DRY-RUN] Would execute: $Description"
        return $true
    }

    Write-Info "$Description..."
    try {
        & $Command
        Write-Success "$Description completed"
        return $true
    }
    catch {
        Write-Error "$Description failed: $_"
        return $false
    }
}

function Copy-FileOrDir {
    param(
        [string]$Source,
        [string]$Destination,
        [string]$Name
    )

    if ($DryRun) {
        Write-Info "[DRY-RUN] Would copy $Source to $Destination"
        return
    }

    if (-not (Test-Path $Source)) {
        Write-Warning "Source not found: $Source"
        return
    }

    Write-Info "Installing $Name"
    if ($Verbose -and (Test-Path $Destination)) {
        Write-Warning "Overwriting existing $Destination"
    }

    try {
        Copy-Item -Path $Source -Destination $Destination -Recurse -Force
        Write-Success "Installed $Name"
    }
    catch {
        Write-Error "Failed to copy $Name: $_"
    }
}

function Remove-FileOrDir {
    param(
        [string]$Path,
        [string]$Name
    )

    if ($DryRun) {
        Write-Info "[DRY-RUN] Would remove $Path"
        return
    }

    if (-not (Test-Path $Path)) {
        if ($Verbose) {
            Write-Warning "Not found: $Path"
        }
        return
    }

    Write-Info "Removing $Name"
    try {
        Remove-Item -Path $Path -Recurse -Force
        Write-Success "Removed $Name"
    }
    catch {
        Write-Error "Failed to remove $Name: $_"
    }
}

function Get-PackageNameWithoutVersion {
    param([string]$Package)
    # Remove version specifiers
    return $Package -replace '(==|>=|<=|>|<|~=|!=|=|:|@).*', ''
}

function Install-DefaultFiles {
    Write-Header "Installing default dotfiles"

    if (-not (Test-Path $DEFAULT_DIR)) {
        Write-Warning "Default directory not found: $DEFAULT_DIR"
        return
    }

    foreach ($entry in $DEFAULT_FILES) {
        $src = Join-Path $DEFAULT_DIR $entry
        $dst = Join-Path $env:USERPROFILE $entry
        Copy-FileOrDir -Source $src -Destination $dst -Name $entry
    }
}

function Install-ConfigFiles {
    Write-Header "Installing .config folders"

    if ([string]::IsNullOrEmpty("windows") -or -not (Test-Path $CONFIG_DIR)) {
        if ($Verbose) {
            Write-Warning "Config directory not found: $CONFIG_DIR"
        }
        return
    }

    if (-not (Test-Path $CONFIG_DST)) {
        New-Item -ItemType Directory -Path $CONFIG_DST -Force | Out-Null
    }

    foreach ($entry in $CONFIG_FILES) {
        $src = Join-Path $CONFIG_DIR $entry
        $dst = Join-Path $CONFIG_DST $entry
        Copy-FileOrDir -Source $src -Destination $dst -Name $entry
    }
}

function Uninstall-DefaultFiles {
    Write-Header "Uninstalling default dotfiles"

    foreach ($entry in $DEFAULT_FILES) {
        $path = Join-Path $env:USERPROFILE $entry
        Remove-FileOrDir -Path $path -Name $entry
    }
}

function Uninstall-ConfigFiles {
    Write-Header "Uninstalling .config folders"

    foreach ($entry in $CONFIG_FILES) {
        $path = Join-Path $CONFIG_DST $entry
        Remove-FileOrDir -Path $path -Name $entry
    }
}

function Install-Section1 {
    Write-Header "Section: core-dev"

    # Pre-install scripts
    Write-Info "Running pre-install scripts..."
    Invoke-Command "Pre-install" {
        Write-Host "Updating winget sources..."
winget source update

    }

    # Install winget packages
    Invoke-Command "Installing core-dev winget packages" {
        winget install --id Microsoft.VisualStudioCode --silent --accept-package-agreements --accept-source-agreements
        winget install --id Git.Git --silent --accept-package-agreements --accept-source-agreements
        winget install --id Microsoft.WindowsTerminal --silent --accept-package-agreements --accept-source-agreements
        winget install --id Microsoft.PowerShell --silent --accept-package-agreements --accept-source-agreements
        winget install --id 7zip.7zip --silent --accept-package-agreements --accept-source-agreements
        winget install --id Notepad++.Notepad++ --silent --accept-package-agreements --accept-source-agreements
    }
    # Post-install scripts
    Write-Info "Running post-install scripts..."
    Invoke-Command "Post-install" {
        Write-Host "Core development tools installed"

    }
}

function Uninstall-Section1 {
    Write-Header "Uninstalling: core-dev"

    # Uninstall winget packages
    $packages = @(
        "$(Get-PackageNameWithoutVersion 'Microsoft.VisualStudioCode')",
        "$(Get-PackageNameWithoutVersion 'Git.Git')",
        "$(Get-PackageNameWithoutVersion 'Microsoft.WindowsTerminal')",
        "$(Get-PackageNameWithoutVersion 'Microsoft.PowerShell')",
        "$(Get-PackageNameWithoutVersion '7zip.7zip')",
        "$(Get-PackageNameWithoutVersion 'Notepad++.Notepad++')",
    )
    Invoke-Command "Uninstalling core-dev winget packages" {
        foreach ($pkg in $packages) {
            winget uninstall --id $pkg --silent
        }
    }
}

function Install-Section2 {
    Write-Header "Section: python"

    # Install winget packages
    Invoke-Command "Installing python winget packages" {
        winget install --id Python.Python.3.12 --silent --accept-package-agreements --accept-source-agreements
    }
    # Post-install scripts
    Write-Info "Running post-install scripts..."
    Invoke-Command "Post-install" {
        Write-Host "Refreshing environment variables..."
refreshenv
Write-Host "Python installed. Verify with: python --version"

    }
}

function Uninstall-Section2 {
    Write-Header "Uninstalling: python"

    # Uninstall winget packages
    $packages = @(
        "$(Get-PackageNameWithoutVersion 'Python.Python.3.12')",
    )
    Invoke-Command "Uninstalling python winget packages" {
        foreach ($pkg in $packages) {
            winget uninstall --id $pkg --silent
        }
    }
}

function Install-Section3 {
    Write-Header "Section: python-packages"

    # Install Python packages
    Invoke-Command "Installing python-packages python packages" {
        python -m pip install pip wheel virtualenv ipython pytest black pylint requests     }
}

function Uninstall-Section3 {
    Write-Header "Uninstalling: python-packages"

    # Uninstall Python packages
    $packages = @(
        "$(Get-PackageNameWithoutVersion 'pip')",
        "$(Get-PackageNameWithoutVersion 'wheel')",
        "$(Get-PackageNameWithoutVersion 'virtualenv')",
        "$(Get-PackageNameWithoutVersion 'ipython')",
        "$(Get-PackageNameWithoutVersion 'pytest')",
        "$(Get-PackageNameWithoutVersion 'black')",
        "$(Get-PackageNameWithoutVersion 'pylint')",
        "$(Get-PackageNameWithoutVersion 'requests')",
    )
    Invoke-Command "Uninstalling python-packages python packages" {
        python -m pip uninstall -y $packages
    }
}

function Install-Section4 {
    Write-Header "Section: dev-tools-choco"

    # Install Chocolatey packages
    # Ensure Chocolatey is installed
    if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
        Write-Info "Installing Chocolatey..."
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
    }
    Invoke-Command "Installing dev-tools-choco chocolatey packages" {
        choco install nodejs-lts -y
        choco install docker-desktop -y
        choco install golang -y
        choco install rust -y
    }
    # Post-install scripts
    Write-Info "Running post-install scripts..."
    Invoke-Command "Post-install" {
        Write-Host "Additional development tools installed via Chocolatey"

    }
}

function Uninstall-Section4 {
    Write-Header "Uninstalling: dev-tools-choco"

    # Uninstall Chocolatey packages
    $packages = @(
        "$(Get-PackageNameWithoutVersion 'nodejs-lts')",
        "$(Get-PackageNameWithoutVersion 'docker-desktop')",
        "$(Get-PackageNameWithoutVersion 'golang')",
        "$(Get-PackageNameWithoutVersion 'rust')",
    )
    Invoke-Command "Uninstalling dev-tools-choco chocolatey packages" {
        foreach ($pkg in $packages) {
            choco uninstall $pkg -y
        }
    }
}

function Install-Section5 {
    Write-Header "Section: browsers"

    # Install winget packages
    Invoke-Command "Installing browsers winget packages" {
        winget install --id Mozilla.Firefox --silent --accept-package-agreements --accept-source-agreements
        winget install --id Google.Chrome --silent --accept-package-agreements --accept-source-agreements
        winget install --id Microsoft.Edge --silent --accept-package-agreements --accept-source-agreements
    }
}

function Uninstall-Section5 {
    Write-Header "Uninstalling: browsers"

    # Uninstall winget packages
    $packages = @(
        "$(Get-PackageNameWithoutVersion 'Mozilla.Firefox')",
        "$(Get-PackageNameWithoutVersion 'Google.Chrome')",
        "$(Get-PackageNameWithoutVersion 'Microsoft.Edge')",
    )
    Invoke-Command "Uninstalling browsers winget packages" {
        foreach ($pkg in $packages) {
            winget uninstall --id $pkg --silent
        }
    }
}

function Install-Section6 {
    Write-Header "Section: utilities"

    # Install winget packages
    Invoke-Command "Installing utilities winget packages" {
        winget install --id VideoLAN.VLC --silent --accept-package-agreements --accept-source-agreements
        winget install --id Adobe.Acrobat.Reader.64-bit --silent --accept-package-agreements --accept-source-agreements
        winget install --id WinSCP.WinSCP --silent --accept-package-agreements --accept-source-agreements
        winget install --id PuTTY.PuTTY --silent --accept-package-agreements --accept-source-agreements
    }
}

function Uninstall-Section6 {
    Write-Header "Uninstalling: utilities"

    # Uninstall winget packages
    $packages = @(
        "$(Get-PackageNameWithoutVersion 'VideoLAN.VLC')",
        "$(Get-PackageNameWithoutVersion 'Adobe.Acrobat.Reader.64-bit')",
        "$(Get-PackageNameWithoutVersion 'WinSCP.WinSCP')",
        "$(Get-PackageNameWithoutVersion 'PuTTY.PuTTY')",
    )
    Invoke-Command "Uninstalling utilities winget packages" {
        foreach ($pkg in $packages) {
            winget uninstall --id $pkg --silent
        }
    }
}

function Install-Section7 {
    Write-Header "Section: configuration"

    # Execute PowerShell commands
    Write-Info "Executing PowerShell commands..."
    Invoke-Command "configuration" {
        # Set execution policy for current user
Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser -Force

# Enable Developer Mode
Write-Host "Enabling Developer Mode..."
reg add "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AppModelUnlock" /t REG_DWORD /f /v "AllowDevelopmentWithoutDevLicense" /d "1"

# Configure Git
if (Get-Command git -ErrorAction SilentlyContinue) {
    git config --global core.autocrlf true
    git config --global init.defaultBranch main
    Write-Host "Git configured"
}

# Create common development directories
$devDirs = @(
    "$env:USERPROFILE\dev",
    "$env:USERPROFILE\projects",
    "$env:USERPROFILE\.ssh"
)
foreach ($dir in $devDirs) {
    if (-not (Test-Path $dir)) {
        New-Item -ItemType Directory -Path $dir -Force | Out-Null
        Write-Host "Created directory: $dir"
    }
}

    }
}

function Uninstall-Section7 {
    Write-Header "Uninstalling: configuration"

    Write-Warning "PowerShell sections cannot be automatically uninstalled"
}

function Install-Section8 {
    Write-Header "Section: wsl-setup"

    # Execute PowerShell commands
    Write-Info "Executing PowerShell commands..."
    Invoke-Command "wsl-setup" {
        # Install WSL 2
Write-Host "Installing WSL 2..."
wsl --install
Write-Host "WSL 2 installation initiated. You may need to restart your computer."
Write-Host "After restart, run: wsl --set-default-version 2"
Write-Host "Then install Ubuntu: wsl --install -d Ubuntu"

    }
}

function Uninstall-Section8 {
    Write-Header "Uninstalling: wsl-setup"

    Write-Warning "PowerShell sections cannot be automatically uninstalled"
}

function Install-Section9 {
    Write-Header "Section: cleanup"

    # Execute PowerShell commands
    Write-Info "Executing PowerShell commands..."
    Invoke-Command "cleanup" {
        Write-Host "Cleaning up temporary files..."
# Clear Windows temp directory
Remove-Item -Path "$env:TEMP\*" -Recurse -Force -ErrorAction SilentlyContinue
# Clear Chocolatey cache if installed
if (Get-Command choco -ErrorAction SilentlyContinue) {
    choco cleanup --confirm
}
Write-Host "Cleanup completed"

    }
}

function Uninstall-Section9 {
    Write-Header "Uninstalling: cleanup"

    Write-Warning "PowerShell sections cannot be automatically uninstalled"
}

function Install-All {
    Write-Header "Installing: $RECIPE_NAME"
    Write-Info "Platform: $PLATFORM"
    Write-Info "OS: $OS_NAME $OS_VERSION ($OS_RELEASE)"
    Write-Host ""

    Install-DefaultFiles
    Install-ConfigFiles
    Install-Section1
    Install-Section2
    Install-Section3
    Install-Section4
    Install-Section5
    Install-Section6
    Install-Section7
    Install-Section8
    Install-Section9
    Write-Host ""
    Write-Success "Installation complete!"
}

function Uninstall-All {
    Write-Header "Uninstalling: $RECIPE_NAME"
    Write-Info "Platform: $PLATFORM"
    Write-Info "OS: $OS_NAME $OS_VERSION ($OS_RELEASE)"
    Write-Host ""

    # Uninstall sections in reverse order
    Uninstall-Section9
    Uninstall-Section8
    Uninstall-Section7
    Uninstall-Section6
    Uninstall-Section5
    Uninstall-Section4
    Uninstall-Section3
    Uninstall-Section2
    Uninstall-Section1
    Uninstall-ConfigFiles
    Uninstall-DefaultFiles

    Write-Host ""
    Write-Success "Uninstallation complete!"
}

function Show-Help {
    @"
Usage: .\script.ps1 <command> [options]

Commands:
    install     Install all packages and files
    uninstall   Uninstall all packages and files

Options:
    -DryRun, -n      Show what would be done without executing
    -Verbose, -v     Enable verbose output
    -Help, -h        Show this help message

Examples:
    .\script.ps1 install                 # Install all packages and files
    .\script.ps1 uninstall               # Uninstall all packages and files
    .\script.ps1 install -DryRun         # Show what would be installed
    .\script.ps1 install -Verbose        # Verbose output
    .\script.ps1 uninstall -DryRun -v    # Show what would be uninstalled

Generated by start-vm for $RECIPE_NAME ($PLATFORM/$OS_NAME)
"@
}

# Show help if requested
if ($Help) {
    Show-Help
    exit 0
}

# Check for administrator privileges (only when not in dry-run mode)
if (-not $DryRun) {
    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
    $isAdmin = $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

    if (-not $isAdmin) {
        Write-Warning "This script requires administrator privileges for package installation."
        Write-Warning "Please run PowerShell as Administrator and try again."
        exit 1
    }
}

# Execute action
switch ($Action) {
    'install' {
        Install-All
    }
    'uninstall' {
        if (-not $DryRun) {
            Write-Warning "This will remove installed packages and files!"
            $response = Read-Host "Are you sure? [y/N]"
            if ($response -notmatch '^[Yy]$') {
                Write-Info "Aborted"
                exit 0
            }
        }
        Uninstall-All
    }
}