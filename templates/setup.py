#!/usr/bin/env python3
"""
Setup script for {{name}}
Platform: {{platform}}
OS: {{os}} {{version}}

Generated by start-vm
Python 3.8+ compatible, uses only standard library
"""

import argparse
import platform
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import List, Optional

# Recipe metadata
RECIPE_NAME = "{{name}}"
PLATFORM = "{{platform}}"
OS_NAME = "{{os}}"
OS_VERSION = "{{version}}"
OS_RELEASE = "{{release}}"

# Paths
CONFIG_DIR = Path("config") / "{{config}}" if "{{config}}" else None
DEFAULT_DIR = Path("default")
HOME_DIR = Path.home()
CONFIG_DST = HOME_DIR / ".config"

# Backup directory (will be set dynamically with timestamp)
BACKUP_DIR = None

# Default files to install
DEFAULT_FILES = [
{% for entry in defaults %}    "{{entry}}",
{% endfor %}]

# Config files to install
CONFIG_FILES = [
{% for entry in configs %}    "{{entry}}",
{% endfor %}]

# Section definitions
SECTIONS = [
{% for section in sections %}    {
    "name": "{{section.name}}",
    "type": "{{section.type}}",
{% if section.pre_install %}
    "pre_install": """{{section.pre_install}}""",
{% endif %}{% if section.type == "shell" %}
    "install": """{{section.install}}""",
{% else %}
    "install": [
{% for package in section.install %}
        "{{package}}",
{% endfor %}
    ],
{% endif %}{% if section.purge %} 
    "purge": [
{% for package in section.purge %}
        "{{package}}",
{% endfor %}
    ],
{% endif %}{% if section.post_install %}
    "post_install": """{{section.post_install}}""",
{% endif %}
    },
{% endfor %}
]

# Color output
class Colors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKCYAN = '\033[96m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'


def print_header(msg: str) -> None:
    """Print section header."""
    print()
    print(f"{Colors.HEADER}{msg}{Colors.ENDC}")
    print("=" * 60)


def print_info(msg: str) -> None:
    """Print info message."""
    print(f"{Colors.OKCYAN}[INFO]{Colors.ENDC} {msg}")


def print_success(msg: str) -> None:
    """Print success message."""
    print(f"{Colors.OKGREEN}[OK]{Colors.ENDC} {msg}")


def print_warning(msg: str) -> None:
    """Print warning message."""
    print(f"{Colors.WARNING}[WARN]{Colors.ENDC} {msg}")


def print_error(msg: str) -> None:
    """Print error message."""
    print(f"{Colors.FAIL}[ERROR]{Colors.ENDC} {msg}")


def run_command(cmd: List[str], description: str, dry_run: bool = False,
                check: bool = True, shell: bool = False) -> Optional[int]:
    """
    Execute a command with error handling.

    Args:
        cmd: Command to execute (list or string if shell=True)
        description: Description of what command does
        dry_run: If True, only print command without executing
        check: If True, raise exception on non-zero exit
        shell: If True, run command in shell

    Returns:
        Exit code or None if dry_run
    """
    if dry_run:
        cmd_str = cmd if shell else ' '.join(cmd)
        print_info(f"[DRY-RUN] Would execute: {cmd_str}")
        return None

    print_info(f"{description}...")
    try:
        if shell:
            result = subprocess.run(cmd, shell=True, check=check,
                                  capture_output=False, text=True)
        else:
            result = subprocess.run(cmd, check=check, capture_output=False, text=True)

        if result.returncode == 0:
            print_success(f"{description} completed")
        return result.returncode
    except subprocess.CalledProcessError as e:
        print_error(f"{description} failed with exit code {e.returncode}")
        if check:
            raise
        return e.returncode
    except FileNotFoundError:
        print_error(f"Command not found: {cmd[0] if isinstance(cmd, list) else cmd}")
        if check:
            raise
        return 127


def backup_file_or_dir(path: Path, name: str, dry_run: bool = False,
                        verbose: bool = False) -> None:
    """Backup existing file or directory before overwriting."""
    global BACKUP_DIR

    if not path.exists():
        return  # Nothing to backup

    if BACKUP_DIR is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        BACKUP_DIR = HOME_DIR / f".dotfiles_backup_{timestamp}"

    backup_path = BACKUP_DIR / name

    if dry_run:
        print_info(f"[DRY-RUN] Would backup {path} to {backup_path}")
        return

    if verbose:
        print_info(f"Backing up existing {path}")

    try:
        # Create backup directory if it doesn't exist
        backup_path.parent.mkdir(parents=True, exist_ok=True)

        if path.is_dir():
            shutil.copytree(path, backup_path, dirs_exist_ok=True)
        else:
            shutil.copy2(path, backup_path)

        if verbose:
            print_success(f"Backed up to {backup_path}")
    except (OSError, shutil.Error) as e:
        print_warning(f"Failed to backup {name}: {e}")


def copy_file_or_dir(src: Path, dst: Path, name: str, dry_run: bool = False,
                     verbose: bool = False, backup: bool = True) -> None:
    """Copy a file or directory with error handling."""
    if dry_run:
        if dst.exists() and backup:
            print_info(f"[DRY-RUN] Would backup existing {dst}")
        print_info(f"[DRY-RUN] Would copy {src} to {dst}")
        return

    if not src.exists():
        print_warning(f"Source not found: {src}")
        return

    # Backup existing file/dir if requested
    if backup and dst.exists():
        backup_file_or_dir(dst, name, dry_run, verbose)

    print_info(f"Installing {name}")
    if dst.exists() and verbose:
        print_warning(f"Overwriting existing {dst}")

    try:
        if src.is_dir():
            if dst.exists():
                shutil.rmtree(dst)
            shutil.copytree(src, dst)
        else:
            shutil.copy2(src, dst)
        print_success(f"Installed {name}")
    except (OSError, shutil.Error) as e:
        print_error(f"Failed to copy {name}: {e}")


def remove_file_or_dir(path: Path, name: str, dry_run: bool = False,
                       verbose: bool = False) -> None:
    """Remove a file or directory with error handling."""
    if dry_run:
        print_info(f"[DRY-RUN] Would remove {path}")
        return

    if not path.exists():
        if verbose:
            print_warning(f"Not found: {path}")
        return

    print_info(f"Removing {name}")
    try:
        if path.is_dir():
            shutil.rmtree(path)
        else:
            path.unlink()
        print_success(f"Removed {name}")
    except (OSError, shutil.Error) as e:
        print_error(f"Failed to remove {name}: {e}")


def install_default_files(dry_run: bool = False, verbose: bool = False,
                          backup: bool = True) -> None:
    """Install default dotfiles to home directory."""
    print_header("Installing default dotfiles")

    if not DEFAULT_DIR.exists():
        print_warning(f"Default directory not found: {DEFAULT_DIR}")
        return

    for entry in DEFAULT_FILES:
        src = DEFAULT_DIR / entry
        dst = HOME_DIR / entry
        copy_file_or_dir(src, dst, entry, dry_run, verbose, backup)


def install_config_files(dry_run: bool = False, verbose: bool = False,
                         backup: bool = True) -> None:
    """Install config files to .config directory."""
    print_header("Installing .config folders")

    if not CONFIG_DIR or not CONFIG_DIR.exists():
        if verbose:
            print_warning(f"Config directory not found: {CONFIG_DIR}")
        return

    if not dry_run and not CONFIG_DST.exists():
        CONFIG_DST.mkdir(parents=True, exist_ok=True)

    for entry in CONFIG_FILES:
        src = CONFIG_DIR / entry
        dst = CONFIG_DST / entry
        copy_file_or_dir(src, dst, entry, dry_run, verbose, backup)


def uninstall_default_files(dry_run: bool = False, verbose: bool = False) -> None:
    """Uninstall default dotfiles from home directory."""
    print_header("Uninstalling default dotfiles")

    for entry in DEFAULT_FILES:
        dst = HOME_DIR / entry
        remove_file_or_dir(dst, entry, dry_run, verbose)


def uninstall_config_files(dry_run: bool = False, verbose: bool = False) -> None:
    """Uninstall config files from .config directory."""
    print_header("Uninstalling .config folders")

    for entry in CONFIG_FILES:
        dst = CONFIG_DST / entry
        remove_file_or_dir(dst, entry, dry_run, verbose)


def strip_version_spec(package: str) -> str:
    """Strip version specifier from package name."""
    # Handle different package manager syntaxes
    for sep in ['==', '>=', '<=', '>', '<', '~=', '!=', '=', ':', '@']:
        if sep in package:
            return package.split(sep)[0]
    return package


def install_section(section: dict, dry_run: bool = False, verbose: bool = False) -> None:
    """Install a section based on its type."""
    print_header(f"Section: {section['name']}")

    # Pre-install scripts
    if section.get('pre_install'):
        print_info("Running pre-install scripts...")
        run_command(section['pre_install'], "Pre-install", dry_run=dry_run, shell=True)

    section_type = section['type']
    install_list = section.get('install', [])

    # Install based on section type
    if section_type == 'debian_packages':
        if install_list:
            cmd = ["sudo", "apt-get", "install", "-y"] + install_list
            run_command(cmd, f"Installing {section['name']} debian packages", dry_run=dry_run)

    elif section_type == 'python_packages':
        if install_list:
            cmd = [sys.executable, "-m", "pip", "install"] + install_list
            run_command(cmd, f"Installing {section['name']} python packages", dry_run=dry_run)

    elif section_type == 'ruby_packages':
        for package in install_list:
            run_command(["gem", "install", package],
                       f"Installing {package}", dry_run=dry_run)

    elif section_type == 'rust_packages':
        for package in install_list:
            run_command(["cargo", "install", package],
                       f"Installing {package}", dry_run=dry_run)

    elif section_type == 'homebrew_packages':
        if install_list:
            run_command(["brew", "install"] + install_list,
                       f"Installing {section['name']} homebrew packages", dry_run=dry_run)

    elif section_type == 'shell':
        print_info("Executing shell commands...")
        run_command(install_list, section['name'], dry_run=dry_run, shell=True)

    # Purge packages
    if section.get('purge') and section_type == 'debian_packages':
        print_info("Purging unwanted packages...")
        purge_pkgs = section['purge']
        run_command(["sudo", "apt-get", "purge", "-y"] + purge_pkgs,
                   f"Purging {section['name']} packages", dry_run=dry_run)

    # Post-install scripts
    if section.get('post_install'):
        print_info("Running post-install scripts...")
        run_command(section['post_install'], "Post-install", dry_run=dry_run, shell=True)


def uninstall_section(section: dict, dry_run: bool = False, verbose: bool = False) -> None:
    """Uninstall a section based on its type."""
    print_header(f"Uninstalling: {section['name']}")

    section_type = section['type']
    install_list = section.get('install', [])

    if section_type == 'debian_packages':
        if install_list:
            packages = [strip_version_spec(pkg) for pkg in install_list]
            cmd = ["sudo", "apt-get", "remove", "-y"] + packages
            run_command(cmd, f"Uninstalling {section['name']} debian packages",
                       dry_run=dry_run, check=False)

    elif section_type == 'python_packages':
        if install_list:
            packages = [strip_version_spec(pkg) for pkg in install_list]
            cmd = [sys.executable, "-m", "pip", "uninstall", "-y"] + packages
            run_command(cmd, f"Uninstalling {section['name']} python packages",
                       dry_run=dry_run, check=False)

    elif section_type == 'ruby_packages':
        for package in install_list:
            pkg_name = strip_version_spec(package)
            run_command(["gem", "uninstall", "-x", pkg_name],
                       f"Uninstalling {pkg_name}", dry_run=dry_run, check=False)

    elif section_type == 'rust_packages':
        for package in install_list:
            pkg_name = strip_version_spec(package)
            run_command(["cargo", "uninstall", pkg_name],
                       f"Uninstalling {pkg_name}", dry_run=dry_run, check=False)

    elif section_type == 'homebrew_packages':
        if install_list:
            packages = [strip_version_spec(pkg) for pkg in install_list]
            run_command(["brew", "uninstall"] + packages,
                       f"Uninstalling {section['name']} homebrew packages",
                       dry_run=dry_run, check=False)

    elif section_type == 'shell':
        print_warning("Shell sections cannot be automatically uninstalled")


def install_all(dry_run: bool = False, verbose: bool = False,
                backup: bool = True) -> None:
    """Run full installation."""
    print_header(f"Installing: {RECIPE_NAME}")
    print_info(f"Platform: {PLATFORM}")
    print_info(f"OS: {OS_NAME} {OS_VERSION} ({OS_RELEASE})")
    print()

    if backup:
        print_info("Backup enabled: existing files will be backed up before overwriting")
    else:
        print_warning("Backup disabled: existing files will be overwritten without backup")

    # Install default files
    install_default_files(dry_run, verbose, backup)

    # Install config files
    install_config_files(dry_run, verbose, backup)

    # Install sections
    for section in SECTIONS:
        install_section(section, dry_run, verbose)

    print()
    if backup and BACKUP_DIR and BACKUP_DIR.exists():
        print_info(f"Backups saved to: {BACKUP_DIR}")
    print_success("Installation complete!")


def uninstall_all(dry_run: bool = False, verbose: bool = False) -> None:
    """Run full uninstallation."""
    print_header(f"Uninstalling: {RECIPE_NAME}")
    print_info(f"Platform: {PLATFORM}")
    print_info(f"OS: {OS_NAME} {OS_VERSION} ({OS_RELEASE})")
    print()

    # Uninstall sections (in reverse order)
    for section in reversed(SECTIONS):
        uninstall_section(section, dry_run, verbose)

    # Uninstall config files
    uninstall_config_files(dry_run, verbose)

    # Uninstall default files
    uninstall_default_files(dry_run, verbose)

    print()
    print_success("Uninstallation complete!")


def main():
    """Main entry point with argparse interface."""
    parser = argparse.ArgumentParser(
        description=f"Setup script for {RECIPE_NAME}",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s install                 # Install all packages and files (with backup)
  %(prog)s uninstall               # Uninstall all packages and files
  %(prog)s install --dry-run       # Show what would be installed
  %(prog)s install --verbose       # Verbose output with backup details
  %(prog)s install --no-backup     # Install without backing up existing files
  %(prog)s uninstall --dry-run -v  # Show what would be uninstalled

Note: By default, existing dotfiles and config files are backed up to
      ~/.dotfiles_backup_<timestamp>/ before being overwritten.
        """
    )

    parser.add_argument(
        'action',
        choices=['install', 'uninstall'],
        help='Action to perform'
    )
    parser.add_argument(
        '-n', '--dry-run',
        action='store_true',
        help='Show what would be done without executing'
    )
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    parser.add_argument(
        '--no-backup',
        action='store_true',
        help='Skip backing up existing files (default: backup enabled)'
    )
    parser.add_argument(
        '--version',
        action='version',
        version=f'%(prog)s for {RECIPE_NAME} ({PLATFORM}/{OS_NAME})'
    )

    args = parser.parse_args()

    # Check platform compatibility
    current_platform = platform.system().lower()
    if current_platform == 'darwin':
        current_platform = 'darwin'
    elif current_platform == 'linux':
        current_platform = 'linux'
    elif current_platform == 'windows':
        current_platform = 'windows'

    if args.verbose:
        print_info(f"Current platform: {current_platform}")
        print_info(f"Target platform: {PLATFORM}")

    if current_platform != PLATFORM and not args.dry_run:
        print_warning(f"Platform mismatch: running on {current_platform}, "
                     f"but recipe is for {PLATFORM}")
        response = input("Continue anyway? [y/N]: ")
        if response.lower() != 'y':
            print_info("Aborted")
            sys.exit(0)

    # Execute requested action
    try:
        if args.action == 'install':
            install_all(args.dry_run, args.verbose, backup=not args.no_backup)
        elif args.action == 'uninstall':
            if not args.dry_run:
                print_warning("This will remove installed packages and files!")
                response = input("Are you sure? [y/N]: ")
                if response.lower() != 'y':
                    print_info("Aborted")
                    sys.exit(0)
            uninstall_all(args.dry_run, args.verbose)
    except KeyboardInterrupt:
        print()
        print_warning("Interrupted by user")
        sys.exit(130)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
