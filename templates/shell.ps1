#
# Setup script for {{name}}
# Platform: {{platform}}
# OS: {{os}} {{version}}
#
# Generated by start-vm
#

param(
    [Parameter(Mandatory=$true, Position=0)]
    [ValidateSet('install', 'uninstall')]
    [string]$Action,

    [Alias('n')]
    [switch]$DryRun,

    [Alias('v')]
    [switch]$Verbose,

    [switch]$NoBackup,

    [Alias('h')]
    [switch]$Help
)

# Set error action preference
$ErrorActionPreference = "Stop"

# Recipe metadata
$RECIPE_NAME = "{{name}}"
$PLATFORM = "{{platform}}"
$OS_NAME = "{{os}}"
$OS_VERSION = "{{version}}"
$OS_RELEASE = "{{release}}"

# Paths
$CONFIG_DIR = "config\{{config}}"
$DEFAULT_DIR = "default"
$CONFIG_DST = "$env:USERPROFILE\.config"

# Default files to install
$DEFAULT_FILES = @(
{% for entry in defaults %}    "{{entry}}",
{% endfor %})

# Config files to install
$CONFIG_FILES = @(
{% for entry in configs %}    "{{entry}}",
{% endfor %})

# Backup directory (will be set dynamically with timestamp)
$BACKUP_DIR = $null
$BACKUP_ENABLED = -not $NoBackup

function Write-Header {
    param([string]$Message)
    Write-Host ""
    Write-Host $Message -ForegroundColor Magenta
    Write-Host "============================================================"
}

function Write-Info {
    param([string]$Message)
    Write-Host "[INFO] $Message" -ForegroundColor Cyan
}

function Write-Success {
    param([string]$Message)
    Write-Host "[OK] $Message" -ForegroundColor Green
}

function Write-Warning {
    param([string]$Message)
    Write-Host "[WARN] $Message" -ForegroundColor Yellow
}

function Write-Error {
    param([string]$Message)
    Write-Host "[ERROR] $Message" -ForegroundColor Red
}

function Invoke-Command {
    param(
        [string]$Description,
        [scriptblock]$Command
    )

    if ($DryRun) {
        Write-Info "[DRY-RUN] Would execute: $Description"
        return $true
    }

    Write-Info "$Description..."
    try {
        & $Command
        Write-Success "$Description completed"
        return $true
    }
    catch {
        Write-Error "$Description failed: $_"
        return $false
    }
}

function Backup-FileOrDir {
    param(
        [string]$Path,
        [string]$Name
    )

    if (-not (Test-Path $Path)) {
        return  # Nothing to backup
    }

    if ($null -eq $script:BACKUP_DIR) {
        $timestamp = Get-Date -Format "yyyyMMdd_HHmmss"
        $script:BACKUP_DIR = "$env:USERPROFILE\.dotfiles_backup_$timestamp"
    }

    $backupPath = Join-Path $script:BACKUP_DIR $Name

    if ($DryRun) {
        Write-Info "[DRY-RUN] Would backup $Path to $backupPath"
        return
    }

    if ($Verbose) {
        Write-Info "Backing up existing $Path"
    }

    try {
        # Create backup directory if it doesn't exist
        $backupParent = Split-Path -Parent $backupPath
        if (-not (Test-Path $backupParent)) {
            New-Item -ItemType Directory -Path $backupParent -Force | Out-Null
        }

        Copy-Item -Path $Path -Destination $backupPath -Recurse -Force

        if ($Verbose) {
            Write-Success "Backed up to $backupPath"
        }
    }
    catch {
        Write-Warning "Failed to backup $Name: $_"
    }
}

function Copy-FileOrDir {
    param(
        [string]$Source,
        [string]$Destination,
        [string]$Name
    )

    if ($DryRun) {
        if ((Test-Path $Destination) -and $script:BACKUP_ENABLED) {
            Write-Info "[DRY-RUN] Would backup existing $Destination"
        }
        Write-Info "[DRY-RUN] Would copy $Source to $Destination"
        return
    }

    if (-not (Test-Path $Source)) {
        Write-Warning "Source not found: $Source"
        return
    }

    # Backup existing file/dir if requested
    if ($script:BACKUP_ENABLED -and (Test-Path $Destination)) {
        Backup-FileOrDir -Path $Destination -Name $Name
    }

    Write-Info "Installing $Name"
    if ($Verbose -and (Test-Path $Destination)) {
        Write-Warning "Overwriting existing $Destination"
    }

    try {
        Copy-Item -Path $Source -Destination $Destination -Recurse -Force
        Write-Success "Installed $Name"
    }
    catch {
        Write-Error "Failed to copy $Name: $_"
    }
}

function Remove-FileOrDir {
    param(
        [string]$Path,
        [string]$Name
    )

    if ($DryRun) {
        Write-Info "[DRY-RUN] Would remove $Path"
        return
    }

    if (-not (Test-Path $Path)) {
        if ($Verbose) {
            Write-Warning "Not found: $Path"
        }
        return
    }

    Write-Info "Removing $Name"
    try {
        Remove-Item -Path $Path -Recurse -Force
        Write-Success "Removed $Name"
    }
    catch {
        Write-Error "Failed to remove $Name: $_"
    }
}

function Get-PackageNameWithoutVersion {
    param([string]$Package)
    # Remove version specifiers
    return $Package -replace '(==|>=|<=|>|<|~=|!=|=|:|@).*', ''
}

function Install-DefaultFiles {
    Write-Header "Installing default dotfiles"

    if (-not (Test-Path $DEFAULT_DIR)) {
        Write-Warning "Default directory not found: $DEFAULT_DIR"
        return
    }

    foreach ($entry in $DEFAULT_FILES) {
        $src = Join-Path $DEFAULT_DIR $entry
        $dst = Join-Path $env:USERPROFILE $entry
        Copy-FileOrDir -Source $src -Destination $dst -Name $entry
    }
}

function Install-ConfigFiles {
    Write-Header "Installing .config folders"

    if ([string]::IsNullOrEmpty("{{config}}") -or -not (Test-Path $CONFIG_DIR)) {
        if ($Verbose) {
            Write-Warning "Config directory not found: $CONFIG_DIR"
        }
        return
    }

    if (-not (Test-Path $CONFIG_DST)) {
        New-Item -ItemType Directory -Path $CONFIG_DST -Force | Out-Null
    }

    foreach ($entry in $CONFIG_FILES) {
        $src = Join-Path $CONFIG_DIR $entry
        $dst = Join-Path $CONFIG_DST $entry
        Copy-FileOrDir -Source $src -Destination $dst -Name $entry
    }
}

function Uninstall-DefaultFiles {
    Write-Header "Uninstalling default dotfiles"

    foreach ($entry in $DEFAULT_FILES) {
        $path = Join-Path $env:USERPROFILE $entry
        Remove-FileOrDir -Path $path -Name $entry
    }
}

function Uninstall-ConfigFiles {
    Write-Header "Uninstalling .config folders"

    foreach ($entry in $CONFIG_FILES) {
        $path = Join-Path $CONFIG_DST $entry
        Remove-FileOrDir -Path $path -Name $entry
    }
}

{% for section in sections %}
function Install-Section{{loop.index}} {
    Write-Header "Section: {{section.name}}"

{% if section.pre_install %}    # Pre-install scripts
    Write-Info "Running pre-install scripts..."
    Invoke-Command "Pre-install" {
        {{section.pre_install}}
    }

{% endif %}{% if section.type == "winget_packages" %}    # Install winget packages
    Invoke-Command "Installing {{section.name}} winget packages" {
{% for package in section.install %}        winget install --id {{package}} --silent --accept-package-agreements --accept-source-agreements
{% endfor %}    }
{% elif section.type == "chocolatey_packages" %}    # Install Chocolatey packages
    # Ensure Chocolatey is installed
    if (-not (Get-Command choco -ErrorAction SilentlyContinue)) {
        Write-Info "Installing Chocolatey..."
        Set-ExecutionPolicy Bypass -Scope Process -Force
        [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072
        Invoke-Expression ((New-Object System.Net.WebClient).DownloadString('https://community.chocolatey.org/install.ps1'))
    }
    Invoke-Command "Installing {{section.name}} chocolatey packages" {
{% for package in section.install %}        choco install {{package}} -y
{% endfor %}    }
{% elif section.type == "python_packages" %}    # Install Python packages
    Invoke-Command "Installing {{section.name}} python packages" {
        python -m pip install {% for package in section.install %}{{package}} {% endfor %}
    }
{% elif section.type == "powershell" %}    # Execute PowerShell commands
    Write-Info "Executing PowerShell commands..."
    Invoke-Command "{{section.name}}" {
        {{section.install}}
    }
{% elif section.type == "shell" %}    # Execute shell commands
    Write-Info "Executing shell commands..."
    Invoke-Command "{{section.name}}" {
        {{section.install}}
    }
{% endif %}
{% if section.post_install %}    # Post-install scripts
    Write-Info "Running post-install scripts..."
    Invoke-Command "Post-install" {
        {{section.post_install}}
    }
{% endif %}}

function Uninstall-Section{{loop.index}} {
    Write-Header "Uninstalling: {{section.name}}"

{% if section.type == "winget_packages" %}    # Uninstall winget packages
    $packages = @(
{% for package in section.install %}        "$(Get-PackageNameWithoutVersion '{{package}}')",
{% endfor %}    )
    Invoke-Command "Uninstalling {{section.name}} winget packages" {
        foreach ($pkg in $packages) {
            winget uninstall --id $pkg --silent
        }
    }
{% elif section.type == "chocolatey_packages" %}    # Uninstall Chocolatey packages
    $packages = @(
{% for package in section.install %}        "$(Get-PackageNameWithoutVersion '{{package}}')",
{% endfor %}    )
    Invoke-Command "Uninstalling {{section.name}} chocolatey packages" {
        foreach ($pkg in $packages) {
            choco uninstall $pkg -y
        }
    }
{% elif section.type == "python_packages" %}    # Uninstall Python packages
    $packages = @(
{% for package in section.install %}        "$(Get-PackageNameWithoutVersion '{{package}}')",
{% endfor %}    )
    Invoke-Command "Uninstalling {{section.name}} python packages" {
        python -m pip uninstall -y $packages
    }
{% elif section.type == "powershell" %}    Write-Warning "PowerShell sections cannot be automatically uninstalled"
{% elif section.type == "shell" %}    Write-Warning "Shell sections cannot be automatically uninstalled"
{% endif %}}

{% endfor %}
function Install-All {
    Write-Header "Installing: $RECIPE_NAME"
    Write-Info "Platform: $PLATFORM"
    Write-Info "OS: $OS_NAME $OS_VERSION ($OS_RELEASE)"
    Write-Host ""

    if ($script:BACKUP_ENABLED) {
        Write-Info "Backup enabled: existing files will be backed up before overwriting"
    }
    else {
        Write-Warning "Backup disabled: existing files will be overwritten without backup"
    }

    Install-DefaultFiles
    Install-ConfigFiles
{% for section in sections %}    Install-Section{{loop.index}}
{% endfor %}
    Write-Host ""
    if ($script:BACKUP_ENABLED -and $script:BACKUP_DIR -and (Test-Path $script:BACKUP_DIR)) {
        Write-Info "Backups saved to: $($script:BACKUP_DIR)"
    }
    Write-Success "Installation complete!"
}

function Uninstall-All {
    Write-Header "Uninstalling: $RECIPE_NAME"
    Write-Info "Platform: $PLATFORM"
    Write-Info "OS: $OS_NAME $OS_VERSION ($OS_RELEASE)"
    Write-Host ""

    # Uninstall sections in reverse order
{% for section in sections | reverse %}    Uninstall-Section{{sections|length - loop.index + 1}}
{% endfor %}    Uninstall-ConfigFiles
    Uninstall-DefaultFiles

    Write-Host ""
    Write-Success "Uninstallation complete!"
}

function Show-Help {
    @"
Usage: .\script.ps1 <command> [options]

Commands:
    install     Install all packages and files
    uninstall   Uninstall all packages and files

Options:
    -DryRun, -n      Show what would be done without executing
    -Verbose, -v     Enable verbose output
    -NoBackup        Skip backing up existing files (default: backup enabled)
    -Help, -h        Show this help message

Examples:
    .\script.ps1 install                 # Install all packages and files (with backup)
    .\script.ps1 uninstall               # Uninstall all packages and files
    .\script.ps1 install -DryRun         # Show what would be installed
    .\script.ps1 install -Verbose        # Verbose output with backup details
    .\script.ps1 install -NoBackup       # Install without backing up existing files
    .\script.ps1 uninstall -DryRun -v    # Show what would be uninstalled

Note: By default, existing dotfiles and config files are backed up to
      %USERPROFILE%\.dotfiles_backup_<timestamp>\ before being overwritten.

Generated by start-vm for $RECIPE_NAME ($PLATFORM/$OS_NAME)
"@
}

# Show help if requested
if ($Help) {
    Show-Help
    exit 0
}

# Check for administrator privileges (only when not in dry-run mode)
if (-not $DryRun) {
    $currentUser = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($currentUser)
    $isAdmin = $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

    if (-not $isAdmin) {
        Write-Warning "This script requires administrator privileges for package installation."
        Write-Warning "Please run PowerShell as Administrator and try again."
        exit 1
    }
}

# Execute action
switch ($Action) {
    'install' {
        Install-All
    }
    'uninstall' {
        if (-not $DryRun) {
            Write-Warning "This will remove installed packages and files!"
            $response = Read-Host "Are you sure? [y/N]"
            if ($response -notmatch '^[Yy]$') {
                Write-Info "Aborted"
                exit 0
            }
        }
        Uninstall-All
    }
}
